/**
Recursive Shape Generator for Fractal Penrose Tiles
<h1>Level of Recursive Generation</h1>
You can control the shapes perimeter with the Level of Recursive Generation slider.
<h2>Recursive Level 0</h2>
Level 0 is equivalent to the Penrose Rhombus Tiles...
@module bZEsZoFg95i
**/

// -------------------------------------------
// Added Automatically During Library Upgrade.
// Convenience Declarations For Dependencies.
// 'Core' Is Configured In Libraries Section.
// -------------------------------------------
var Debug = Core.Debug;
var Mesh3D = Core.Mesh3D;
var Path2D = Core.Path2D;
var Plugin = Core.Plugin;
var Tess = Core.Tess;
var Solid = Core.Solid;

// -------------------------------------------
// Fractal Penrose Tile Generator Script:
// -------------------------------------------
params = [
	{ "id": "level", "displayName": "Recursive Level", "type": "int", "rangeMin": 0, "rangeMax": 14, "default": 2 },
	{ "id": "tile", "displayName": "Tile Type", "type": "list", "listLabels": ["Wide Rhombus", "Narrow Rhombus"], "listValues": ["w", "n"], "default": "w" },
	{ "id": "size", "displayName": "Size", "type": "length", "rangeMin": 10, "rangeMax": 50, "default": 20 },
	{ "id": "vertical_scale", "displayName": "Vertical Scale", "type": "length", "rangeMin": 0.1, "rangeMax": 10, "default": 1.2 }
];

function toRad(degrees) { return degrees * 0.0174532925; }

// yurt is a turtle graphics style vector lib
var yurt = {
  x:0,
  y:0,
  z:1,
  heading:0,
  fd: function (d) {
      this.x = this.x + d * Math.cos(toRad(this.heading));
      this.y = this.y + d * Math.sin(toRad(this.heading));
    },
  rt: function (t) {this.heading += t;},
  lt: function (t) {this.heading -= t;},
  rise: function (h) {this.z += h;},
	level: function (l) {this.z = l;}
};

// the narrow tile
// s->scale, vs->vertical scale, mesh->3d drawing context, vl->vertical level
function n (s, vs, mesh, vl) {
  var top_pts = [];
  var bot_pts = [];
  var vtilt = (vl === 1)? -1.0: 1.0;
	vl = (vl === 1)? 3: 0;

	yurt.level(vl*vs);
  top_pts.push([yurt.x, yurt.y, yurt.z]);
  bot_pts.push([yurt.x, yurt.y, 0]);

  yurt.rt(2 * 36);
  yurt.fd(s);
  yurt.rise(vs*vtilt);

  top_pts.push([yurt.x, yurt.y, yurt.z]);
  bot_pts.push([yurt.x, yurt.y, 0]);

  yurt.lt(4 * 36);
  yurt.fd(s);
  yurt.rise(vs*vtilt);

  top_pts.push([yurt.x, yurt.y, yurt.z]);
  bot_pts.push([yurt.x, yurt.y, 0]);

  yurt.lt(1 * 36);
  yurt.fd(s);
  yurt.rise(vs*vtilt*-1);

  top_pts.push([yurt.x, yurt.y, yurt.z]);
  bot_pts.push([yurt.x, yurt.y, 0]);

  yurt.lt(4 * 36);
  yurt.fd(s);
  yurt.rise(vs*vtilt*-1);

  yurt.lt(1 * 36);
  yurt.lt(2 * 36);

  //top surface
  mesh.quad(top_pts[0], top_pts[1], top_pts[2], top_pts[3]);
  // sides
  mesh.quad(top_pts[0], top_pts[1], bot_pts[1], bot_pts[0]);
  mesh.quad(top_pts[1], top_pts[2], bot_pts[2], bot_pts[1]);
  mesh.quad(top_pts[2], top_pts[3], bot_pts[3], bot_pts[2]);
  mesh.quad(top_pts[3], top_pts[0], bot_pts[0], bot_pts[3]);
  // bottom
  mesh.quad(bot_pts[0], bot_pts[1], bot_pts[2], bot_pts[3]);

}

function w (s, vs, mesh, vl) {
  var top_pts = [];
  var bot_pts = [];
	var vtilt = (vl === 1)? 1: -1;

	yurt.level(vl*vs);
  top_pts.push([yurt.x, yurt.y, yurt.z]);
  bot_pts.push([yurt.x, yurt.y, 0]);

  yurt.rt(1 * 36);
  yurt.fd(s);
  yurt.rise(vs*vtilt);

  top_pts.push([yurt.x, yurt.y, yurt.z]);
  bot_pts.push([yurt.x, yurt.y, 0]);

  yurt.lt(2 * 36);
  yurt.fd(s);
  yurt.rise(vs*vtilt);

  top_pts.push([yurt.x, yurt.y, yurt.z]);
  bot_pts.push([yurt.x, yurt.y, 0]);

  yurt.lt(3 * 36);
  yurt.fd(s);
  yurt.rise(vs*vtilt*-1);

  top_pts.push([yurt.x, yurt.y, yurt.z]);
  bot_pts.push([yurt.x, yurt.y, 0]);

  yurt.lt(2 * 36);
  yurt.fd(s);
  yurt.rise(vs*vtilt*-1);


  yurt.lt(3 * 36);
  yurt.lt(1 * 36);

  //top surface
  mesh.quad(top_pts[0], top_pts[1], top_pts[2], top_pts[3]);
  // sides
  mesh.quad(top_pts[0], top_pts[1], bot_pts[1], bot_pts[0]);
  mesh.quad(top_pts[1], top_pts[2], bot_pts[2], bot_pts[1]);
  mesh.quad(top_pts[2], top_pts[3], bot_pts[3], bot_pts[2]);
  mesh.quad(top_pts[3], top_pts[0], bot_pts[0], bot_pts[3]);
  // bottom
  mesh.quad(bot_pts[0], bot_pts[1], bot_pts[2], bot_pts[3]);
}

// s->scale, k->kind[wide, narrow], depth->recursive depth,
// h->height-scale-factor, mesh->3d drawing context, v-vertical level
function gen (s, k, depth, h, mesh, v) {
  //'use strict';
  var scale, dep, new_v;
  if (depth < 1) {
    if (k === 'w') {
      w(s, h, mesh, v);
    }
		else {
			n(s, h, mesh, v);
		}
  }
  else {
    dep = depth - 1;
    scale = s * 0.618034;

    if (k === 'n') {
      // generate a narrow and wide
      // first the narrow tile
      yurt.fd(scale);
      yurt.rt(3 * 36);
			new_v = (v === 1)? 1: 2;
      gen(scale, 'n', dep, h, mesh, new_v);

      yurt.lt(2 * 36);
      yurt.fd(scale);
      yurt.rt(3 * 36);

			new_v = (v === 2)? 1: 2;
      gen(scale, 'w', dep, h, mesh, new_v);

      yurt.rt(1 * 36);
      yurt.fd(scale);
      yurt.rt(1 * 36);
      yurt.fd(scale);

      yurt.rt(4 * 36);
	  }
	  if (k === 'w') {
	    // w -> w n w
	    // first generate w
	    yurt.rt(2 * 36);
	    yurt.fd(s);
	    yurt.rt(5 * 36);

			new_v = (v === 1)? 1: 2;
	    gen(scale, 'w', dep, h, mesh, new_v);

	    yurt.rt(2 * 36);
	    yurt.fd(scale);
	    yurt.lt(3 * 36);

			new_v = (v === 2)? 1: 2;
	    gen(scale, 'n', dep, h, mesh, new_v);

	    // lastly another w

	    yurt.rt(2 * 36);
	    yurt.fd(scale);
	    yurt.rt(2 * 36);
	    yurt.fd(scale);
	    yurt.rt(4 * 36);

			new_v = (v === 2)? 1: 2;
	    gen(scale, 'w', dep, h, mesh, new_v);

	    yurt.rt(1 * 36);
	    yurt.fd(s * 1.618034);
	    yurt.lt(5 * 36);
	  }
	}
}

function process(params) {

	var level = params['level'] || 0;
	var tile = params['tile'] || 'w';
	var size = params["size"] || 4;
	var vertical_scale = params["vertical_scale"] || 1.2;

	var mesh = new Mesh3D();
	var starting_tilt = true;
	var starting_z = 0;
	var starting_vLevel = (tile === 'w')? 1: 2;

  gen(size, tile, level, vertical_scale, mesh, starting_vLevel);

	return Solid.make(mesh);
}
// -------------------------------------------
// Added Automatically During Library Upgrade.
// Original Shape Color. Changing Effects The
// Default Color In All Documents Where Used.
// -------------------------------------------
presets = [
  { 'color': [210, 10, 250] }
];
